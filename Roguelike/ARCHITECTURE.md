# Dune Rogue

## Общие сведения о системе

### Назначение системы
Система представляет из себя игру жанра Roguelike в сеттинге вселенной "Дюна" Фрэнка Герберта.
Система служит для развлечения пользователя.

### Границы системы
* Игра является однопользовательской.
* Консольная графика с плоским "видом сверху". 
* Игра побита на уровни. 
Каждый уровень представляет из себя двумерную сетку, в каждой ячейки которой может распологаться какая-то из игровых сущностей.
 и не приведшее к завершению уровня
### Контекст
* Поддержка платформ Windows и Linux (работоспособность под MacOS будет проверяться лишь запуском тестов).
* Установка будет произодится путем клонирования репозитория с GitHub и выполнения инструкций по установке.

## Architectural drivers

### Технические ограничения
* Необходимо использовать кроссплатформенные технологии, чтобы система поддерживалась на целевых системах.
### Бизнес-ограничения
* Сроки реализации очень небольшие. Поэтому использование неизвестных команде технологий или долгое планирование является проблематичным.
* У проекта нет финансирования, поэтому нет возможности использовать платное ПО, которым на данный момент команда не обладает.

### Качественные характеристики системы
* Система должна быть хорошо расширяемой, т.к. с течением времени необходимо будет реализовать новый функционал, который
нельзя спрогнозировать заранее. Важна структура проекта.
* Необходимо учитывать, что может придти человек извне реализовывать новую функциональность.
* Корректность работы важна, но не является критической.
* От системы не требуется высокой производительности в силу ее предполагаемой вычислительной простоты.
* Нет предпосылок к тому, чтобы в дальнейшем сопровождать систему.
* Не предпологается, что пользователи будут модифицировать систему самостоятельно.
* Не предполагается хранение и использование пользовательских данных, поэтому вопрос безопасности неактуален.

### Ключевые функциональные требования
* В игре должно быть взаимодействие персонажа, управляемого игроком, с другими сущностями 
(сражение с врагами, инвентарь, перемещение по миру).
* Должна быть возможность сохранять прогресс.
* Программа должна работать через терминал.
* Управление должно осуществлятся при помощи клавиатуры.

## Роли и случаи использования
### Роли
* Пользователь (игрок).
* Программист извне, который пришел в наш проект делать новую функциональность.
### Случаи использования
* Пользователь хочет сыграть в игру. При этом не хочется останавливать сеанс игры где-то по-середине уровня, т.е. они не должны быть слишком большими.
* Программист пришел и ему дали задачу X. Ему хочется поверхностно ознакомится со всей системой и более подробно с частью
системы, связанной с X. Для облегчения его участи необходима хорошая документация системы и комментарии в коде. 
### Типичный пользователь
Имя: Виталий Цаль

Возраст: 33 года

Фото: 

![Виталий](images/vitaliy.png)

Виталий -- ведущий разработчик в компании Hidden Pool. Преимущественно работает под операционной системой семейства Linux.
У Виталия крайне плотный график, но иногда в промежутках между встречами и решением рабочих задач он хочет немного 
отвлечься и отдохнуть. Когда-то давно он читал "Дюну" Фрэнка Герберта, терминала и сложностей roguelike жанра Виталий не боится,
поэтому "Dune Rogue" будет отличным решением, чтобы пару раз за день отвлечься от работы минут на 5-10 или провести досуг 
уже после окончания рабочего дня. 

## Композиция
![Схема композиции](images/component.jpg)

### User Input Handler
Отвечает за считывание пользовательского ввода 

### Game Logic
Подсистема, состоящая из компонент ответсвенных за логику и процесс игры

#### Level Generator/Loader
Компонента(ы) отвечающая за генерацию/загрузку уровней игры

#### AI Logic
Компонента регулирующая поведение неподконтрольных игроку игровых сущностей

#### Inventory Logic
Компонента отвечающая за взаимодействие пользователя с инвентарем

#### Player Logic
Компонента обработки действий игрока

#### Game Control
Компонента, связывающая остальные компоненты игровой логики.

### UI
Подсистема, ответственная за отрисовку игры

#### Game World
Отрисовка игрового мира и интерфейса игрока

#### Menus
Отрисовка меню

#### Inventory
Отрисовка инвентаря

### CLI Graphics Library
Сторонняя библиотека помогающая с выводом графики в консоль

## Логическая структура
Стиль: Model-View-Control.
![Схема классов](images/classes.jpg)

### Color
RGB представление цвета.

### Glyph
Символы для отресовки объектов, хранят в себе сам символ `character` и его цвет `color`. 

### Stats
Значения статистик. Включает в себя различные показатели типа здоровья, защиты и т.п.

### CharacterStats
Статистика персонажей, которая может меняться методами `add/removeStats` при использовании предметов или получении урона.

### PlayerStats
Расширение `CharacterStats`, позволяющее производить прокачку персонажа. 

### InventoryItem
Базовый класс предметов в инвенторе. Имеет вес `weight`, флаг о возможности экипировки на персонажа `canBeEquiped`, 
описание предмета `description`, флаг о возможности использования `usable` и характеристики для предмета `Stats`, 
которые применяются к персонажу, если он надевает/использует предмет. Методы `equip` и `use` отвечают за использование предмета.
Метод `getBonuses` возвращает статистики, которые дает предмет. `getBonusesStr` генерирует текстовое представление бонусов. 

Далее строится иерархия предметов, например оружие и броня, как показано на схеме (`Weapon`, `Armor`)   

### Inventory
Инвентарь персонажа. Хранит в себе объекты `InventoryItems`. Имеет поле `capacity`, ограничивающее переносимый вес. 
Методы `add/removeItem` отвечают за добавление и удаление предметов из инвенторя, метод `canTake` говорит можно ли взять
переданный в аргументе вес. 

### Behavior
Абстрактный класс, отвечающий за поведение NPC. Его наследниками сейчас являются агрессивное, трусливое, пассивное и случайные поведения.

Противник с агрессивным поведением начинает преследовать игрока, если тот находится в определенной близости к нему, иначе случайно блуждает.

Противник с пассивным поведением стоит на месте и атакует игрока, если тот находится на соседней клетке.

Противник с трусливым поведением ведет аналонично агрессивному с разницей в том, что он начинает убегать от игрока, а не преследовать его.

Противник со случайным поведением случайно бродит.

### StatusEffect
Абстрактный класс, наследник `Behavior`. Отвечает за модификацию поведения и представляет из себя паттерн декоратор. 
Параметризуется оборачиваемым поведением и длительностью действия. Сейчас единственный наследник -- `Confused`, заставляющий
сущность двигаться случайно.
 
### GameEntity
Родительский класс всех игровых сущностей (персонажей, элементов карты, предметов). Содержит поля координат `x/yCoord`,
символ для отрисовки `glyph` (можно заменить какими-то спрайтами при желании),
флаг можно ли наступать на данный объект `solid` (например через стены ходить нельза, а по полу можно) и флаг
существует ли данный объект `isAlive` (например когда побеждаем противника, он перестает существовать). 
Метод `intersect` отвечает за обработку события пересечения с другим объектом (например хотим подбирать предметы) 

### StaticEntity
Наследник `GameEntity`, является родительским классом для сущностей, которые никак не меняются от кадра к кадру 
(как пример приведены обычные стены и полы `Wall`, `Floor`).

### ActingEntity
Наследник `GameEntity`, является родительским классом для сущностей, которые могу действовать. Имеют метод `update`, 
который срабатывает на каждом обновлении кадра. Обращается к объекту `Mediator` для взаимодействия с объектом уровня `Level`.

### ItemEntity
Наследник `ActingEntity`. Класс для представления сущности выброшенного предмета. Содержит в себе ссылку на соответсвуюший
`InventoryItem`.

### CharacterEntity
Наследник `ActingEntity`, представляет из себя персонажей игры. Содержит статистики персонажа `CharacterStats`, 
его инвентарь `Inventory` и флаг является ли персонаж врагом. Метод `makeDamage` обрабатывает поступающий урон. 
На схеме показан пример как от данного класса можно насследовать врагов

### PlayerCharacter
Наследник `CharacterEntity`, представляющий из себя персонажа игрока. Отличается в замене `CharacterStats` 
на `PlayerStats`.  Может использовать снимать и надевать предметы за что отвечают методы `useItem`, `equipItem`, `unequipItem`. 
Содержит в себе ссылки на экипированные предметы (сейчас оружие и броня).

### NPC
Наследник `CharacterEntity`. Базовый класс неигровых персонажей

### Enemy
Наследник `NPC`. Базовый класс для врагов. Они могут атаковать игрока и быть атакованы им. Далее от него наследуются уже 
конкретные враги.

### Replicating 
Наследник `Enemy`. Реплицирующаяся сущность, реализующая паттерн прототип. 

### EntityFactory
Абстрактная фабрика для создания нужных сущностей. Наследники умеют создавать существ по обределенной тематике. Паттерн абстрактная фабрика. 

### Scene
Интерфейс, наследники которого умеют представлять себя в формате необходимом для вывода на экран (`render`) и 
обрабатывать ввод пользователя (`processInput`).

### Menu
Интерфейс для представлений меню, наследник `Scene`. Метод `open` отвечает за установку состояния при открытии.

### SimpleMenu 
Наследник `Menu` Интерфейс для  простых меню с навигацией вверх/вниз.

### MainMenu
Наследник `SimpleMenu`. Главное меню игры с возможносятми начала новой игры, загрузки, выбора уровня, режим данжа 
(бесконечная случайная генерация) и выхода.

### PauseMenu
Наследник `SimpleMenu`. Меню паузы. Можно продолжить игру, сохранить ее или выйти в главное меню.

### LvlSelectMenu
Наследник `SimpleMenu`. Меню выбора уровня с которого начать игру.

### InventoryMenu
Меню инвенторя. Можно использовать предметы и выбрасывать их. 

### Level
Объект для представления уровня, наследник `Scene`. Хранит в себе список сущностей `GameEntity`. 
Метод `update` вызывает у всех активных сущностей `update`. 
Отдельно хранит ссылку на персонажа игрока. Флаг `isFinished` говорит о завершенности уровня.

Уровень может либо грузится из файла определенного формата, либо генерироваться случайно.

Формат файла уровня таков: сначала идут его размеры, затем задается статическое поле (пол, стены), затем 
перечисляются специальные сущности с координатами (враги, игрок и пр.).

Уровень завершается, когда игрок доходит до специальной сущности (можно ее например делать неактивной, пока не выполнены 
какие-то условия).

### LevelBuilder
Интрефейс отвечающий за строительство уровней. Паттерн строитель. Можно параметризовать размер уровня и сбрасывать строитель в начальное состояние (например для загрузки предопределенных увроней с начала).

### LevelLoader
Наследник `LevelBuilder`. Умеет грузить следующий уровень из файла по запросу.

### LevelGenerator
Наследник `LevelBuilder`. Случайно генерирует уровень по заданному размеру. Процесс генерации таков: генерируется случайное количество комнат случайного размера, далее эти комнаты соединяются коридорами, далее в комнатах генерируются случайно различные игровые сущности (начальная позиция игрока, враги, предметы и т.д.) 

### Mediator
Посредник, повзоляющий действующим сущностям `ActingEntity` получать информацию о другиъ сущностях, которые находятся на уровне. Позволяет размещать новые сущности.

### FrameBuilder
Класс отвечающий за отрисовку сцены. Пока никаких подробностей нет, т.к. зависит от выбранной библиотеки.

### Action
Перечисление действий пользователя.

### InputHandler
Обработчик пользовательского ввода, преобразует ввод с клваиатуры в элементы `Action`.

### GameState
Перечисление состояний игры. Игрок может находится в каком-то меню или на игровой карте,
в зависимости от этого активны разные сущности. Каждая сущность после обработки очередного действия возвращает новое состояние.

### GameControl
Класс связывающий остальные вместе и запускающий цикл программы. Хранит текущее состояние и в зависимости от него
дает управление той или иной `Scene`. Умеет сохранять или загружать игру, если состояние `SAVE/LOAD`.   

## Взаимодействия и состояния
### Состояния игры
![Схема состояний](images/state.jpg)

При запуске игры игрок находится в состоянии Main Menu и видит главное меню. Из главного меню он может завершить программу,
выбрав соответсвующую опцию. При выборе New Game или Load Game игрок начинает новую игру и попадает в состояние Level 
или загружает последнее сохранение и, проходя через состояние Load, также попадает в состояние Level.
Состояние Level представляет из себя игровую карту уровня, где игрок управляет персонажем. При нажатии кнопки открытия
инвенторя происходит переход в состояние Inventory, где игрок пользуется инвентарем, при нажатии кнопки закрытия инвернторя
приложение возвращается в состояние Level. При нажатии кнопки открытия меню пазу происходит переход в состояние Pause Menu, 
из этого состояния можно перейти в Main Menu, выбрав соответсвующую опцию, можно просто вернутся к игре, 
выбрав пункт продолжить, а можно выбрать опцию сохранения игры, которая проходя состояние Save, отвечающее за сохранение,
вернет программу в состояние Level.

### Последовательность
![Схема последовательности](images/sequence.jpg)
Пример последовательности одной итерации игры, когда на пользователь не совершил действие, переводящее игру из состояния 
Level в другое и не приведшее к завершению уровня. 

Контроллер ждет от InputHandler действие, которое совершит игрок. Handler считывает нажатую клавишу и возвращает 
соответсвующее ей действие. Далее это действие передается на обработку в уровень. Уровень обрабатывает действие 
(в рассматриваемой ситуации это например перемещение или взятие предмета). Затем уровень обращается ко всем ActingEntity
на уровне и зовет у них функцию отвечающую за их действия. После, уровень возвращает новое состояние, в данном случае это 
снова состояние уровня. Далее контроллер просит у уровня его представление, которое можно отрисовать (символы + их цвета) 
и передает это в Drawer, который уже отрисовывает состояние уровня пользователю. Далее все эти действия повторяются.

## Выбор графической библиотеки
Была выбрана библиотека `curses` из-за ее простоты в ипользовании, кроссплатформенности и наложении минимальных ограничений. 

Например, была попытка воспользоваться библиотекой `npyscreen` чтобы отдельно не писать различные меню,
но данная библиотека накладывала определенные ограничения на архитектуру (библиотека становится центральной компонентой) 
и не позволяла легко встроить ее в ранее разработанную архитектуру. Многие популярные библиотеки страдают этим.
По этим причинам и была выбрана `curses` -- она достаточно популярна и в случае проблем можно найти информацию в интернете,
функционал достаточен для наших нужд (рисовать цветные символы) и при этом легко встраивалась в имеющееся решение, не накладывая 
почти никаких ограничений.  